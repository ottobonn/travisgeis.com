{
    "componentChunkName": "component---src-pages-post-slug-tsx",
    "path": "/2020/07/05/homeassistant-in-docker-on-synology-nas/",
    "result": {"data":{"post":{"slug":"2020/07/05/homeassistant-in-docker-on-synology-nas","title":"Homeassistant in Docker on Synology NAS","date":"5 July 2020","parent":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Homeassistant in Docker on Synology NAS\",\n  \"date\": \"2020-07-05T19:13:08.000Z\",\n  \"tags\": null,\n  \"lede\": \"Running homeassistant, nginx proxy manager, and pihole as virtual hosts to turn one NAS into many LAN servers with arbitrary open ports.\",\n  \"project\": \"Home Automation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.home-assistant.io/\"\n  }, \"homeassistant\"), \" to control my apartment\\u2019s lighting and some other fun things like the tea kettle. I definitely recommend it; it\\u2019s open-source and very easy to set up, and it supports many devices right away with minimal fuss. I\\u2019ll go into more detail on my home automation devices in another post. This one is about the software, and the surprising complexity of home networks.\"), mdx(\"p\", null, \"Many people run homeassistant on a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.raspberrypi.org/\"\n  }, \"Raspberry Pi\"), \", but I already had a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.synology.com/en-global/products/DS218+\"\n  }, \"Synology DS218+\"), \" NAS (network-attached storage) device that I wanted to use for home automation, too. It\\u2019s a suprisingly capable little Linux server, and since it\\u2019s always running anyway for network backups, it\\u2019s a good candidate for a home automation server.\"), mdx(\"p\", null, \"In this blog post I want to explain some of the challenges of setting up a cluster of applications on the NAS and how I eventually decided to do it.\"), mdx(\"h2\", null, \"Docker for personal projects\"), mdx(\"p\", null, \"The NAS is a computer like any other, so one option for setting up additional apps on it is to install them normally and let them control the NAS\\u2019s available ports to talk to the local network. However, installing applications one-by-one like you might on a personal computer has a few downsides:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The applications might not be compatible with Synology\\u2019s specific Linux distribution, \\u201CDSM\\u201D (I\\u2019m not even sure what distro it\\u2019s based on).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Synology updates could inadvertently wipe out or break third-party apps I\\u2019ve installed, particularly if I need to reconfigure a preinstalled app like nginx.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I will \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"definitely forget\"), \" how I installed the apps, and when I get a new NAS I will have to start from scratch to set thigs up again.\")), mdx(\"p\", null, \"Instead of installing the apps individually, I committed to using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.docker.com/\"\n  }, \"Docker\"), \" to run each app in its own container. Docker is useful in a professional software environment for isolating applications from their host operating system and managing their dependencies, but it\\u2019s also amazing for personal projects, because it allows the developer to completely describe how an application should be configured so that the setup is reproducible later. It\\u2019s very easy to forget how a personal project works, so I really value the self-documenting nature of docker containers.\"), mdx(\"h2\", null, \"Default ports on Synology NAS\"), mdx(\"p\", null, \"Okay, there\\u2019s a catch---surely you knew there would be!\"), mdx(\"p\", null, \"The Synology NAS runs its own web server, listening on ports 80 and 443 (the defaults for HTTP and HTTPS). While it is possible to free those two ports, doing so involves editing the default nginx configuration files for the NAS to move its web applications to other default ports, and those changes might not persist across OS updates. Furthermore, changes to the default ports make the NAS more annoying to use for its original purpose, and might break features that the Synology developers add later on.\"), mdx(\"p\", null, \"I wanted to preserve the original functionality of the NAS, so I opted not to mess with the default ports. I assumed there must be a better way, and this blog post documents some of them.\"), mdx(\"h2\", null, \"Running homeassistant in host networking mode\"), mdx(\"p\", null, \"I started by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.home-assistant.io/docs/installation/docker/\"\n  }, \"running homeassistant in its own Docker container in host networking mode\"), \", listening on its default port of 8123. In host networking mode, the Docker container attaches directly to the network interface of the host computer, so it behaves like the application is running on the host for the purposes of networking.\"), mdx(\"p\", null, \"In this configuration, Docker provides isolation from the host operating system and keeps other ports on the container closed to traffic, and we still get the dependency management and reproducible setup of Docker containers, but we aren\\u2019t taking advantage of any virtual networking features.\"), mdx(\"p\", null, \"My NAS is on the local network at \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"nas.ivy.travisgeis.com\"), \", so I could see the homeassistant web interface at \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"nas.ivy.travisgeis.com:8123\"), \". The NAS doesn\\u2019t use port 8123 for anything else, so it was available for homeassistant to use. Setting up this way was very quick, but I\\u2019m picky and I don\\u2019t like typing port 8123 every time I visit the homeassistant UI! I want to be able instead to use a different URL, like \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"homeassistant.example.com\"), \" to access the UI without specifying a port, which means the application needs to be available on the default port 80.\"), mdx(\"h2\", null, \"nginx as reverse proxy\"), mdx(\"p\", null, \"With homeassistant running and the goal of making it available on its own URL, the next step is to add a reverse proxy to route traffic at this new URL to the actual port 8123. A reverse proxy intercepts traffic on the host machine and can route it to different applications based on properties of the traffic like the URL, the port, or the protocol.\"), mdx(\"p\", null, \"I am familiar with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://nginx.org/\"\n  }, \"nginx\"), \", a popular web server, so I decided to use it as a reverse proxy, but there are other options with the same features. Here is a diagram of nginx running as a reverse proxy on the NAS, directing traffic to our homeassistant URL to the homeassistant port, 8123:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/9a6e1d3fdd0fcbfd2aad1ff93155510c/nginx-reverse-proxy.svg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"This diagram shows how other services could use additional ports on the host, but I only configured homeassistant to run this way.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2020/07/11/nginx-configuration-for-reverse-proxy-to-different-ports/\"\n  }, \"Here is the nginx config\"), \" I used to set it up.\"), mdx(\"p\", null, \"This nginx configuration declares one server listening on port 80, passing all traffic to \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"http://localhost:$target_port\"), \". The target port comes from the mapping declared above, based on the name of the service. For the case of homeassistant, \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"homeassistant.nas.ivy.travisgeis.com\"), \" will provide a \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"$name\"), \" of \\u201Chomeassistant,\\u201D which will map to port 8123.\"), mdx(\"p\", null, \"This nginx reverse proxy works well for simple services like homeassistant that run on the host\\u2019s network and need to expose one or a handful of ports. However, it doesn\\u2019t work for services that need to listen to non-http network traffic, like a DNS server. My next project was to set up \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pi-hole.net/\"\n  }, \"pihole\"), \", a DNS server and ad blocker, so I was back on the hunt for a way to have multiple apps running on the NAS seamlessly.\"), mdx(\"p\", null, \"One caveat for running nginx this way on the NAS: Synology provides its own default nginx configuration, and nginx runs on the NAS to host the buit-in web interfaces. In order for this copy of nginx to bind to port 80, I had to stop the already-running default instance. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://tech.setepontos.com/2018/03/25/control-synology-dsm-services-via-terminal-ssh/\"\n  }, \"Here is a good guide\"), \" on managing built-in services with Synology\\u2019s package system, \\u201Csynopackagectl\\u201D.\"), mdx(\"h2\", null, \"Aside: Running \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"http://nginx.org/\"\n  }, \"nginx\"), \" in a container\"), mdx(\"p\", null, \"Because the NAS already had a global nginx configuration for serving its own web interface, I wanted to run a separate copy of nginx in a container. Running my copy in a container keeps my configuration isolated from the global configs, and provides the usual ease of building that containers allow.\"), mdx(\"p\", null, \"While I was researching running nginx in a container, I happened across \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nginxproxymanager.com/\"\n  }, \"Nginx Proxy Manager\"), \". It provides a graphical interface for configuring reverse-proxy settings for different services, further reducing the risk of completely forgetting how everything works.\"), mdx(\"h2\", null, \"Adding \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"https://pi-hole.net/\"\n  }, \"pihole\")), mdx(\"p\", null, \"Next I wanted to set up pihole for LAN-wide ad blocking. pihole is a bit different from homeassistant, because it requires access to DNS queries, which don\\u2019t (usually) happen over HTTP.\"), mdx(\"p\", null, \"Running pihole poses a few challenges:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It needs access to non-HTTP ports.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It also wants to run a server on port 80 for its web UI.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It needs to have its own IP address, so the LAN router can point to it as the DNS server.\")), mdx(\"p\", null, \"Pihole expects to run on the LAN at a static IP on a dedicated host. To get it running in Docker, I needed to emulate a separate host within the Synology NAS.\"), mdx(\"h2\", null, \"Multiple virtual hosts with Docker macvlan\"), mdx(\"p\", null, \"Docker has a networking driver called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.docker.com/network/macvlan/\"\n  }, \"macvlan\"), \" that allows each container to have its own (virtualized) MAC address and IP address on the LAN. Perfect for the pihole! Thanks to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://tonylawrence.com/posts/unix/synology/free-your-synology-ports/\"\n  }, \"Tony Lawrence for his excellent guide\"), \" on setting up macvlan, which I adapted for this setup.\"), mdx(\"p\", null, \"Using macvlan results in a pretty different network topology than using the host-mode network recommended for homeassistant. Each container on the macvlan network gets a unique IP address and MAC address on the LAN, and the macvlan network is isolated from the host. Basically you get extra virtual hosts from one computer!\"), mdx(\"p\", null, \"Here are the basic steps required to transition the containers to a macvlan network:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Decide on a range of IP addresses for the Docker containers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create the macvlan network in Docker and allocate the reserved IP addresses to it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attach the containers to the new macvlan network.\")), mdx(\"p\", null, \"Here\\u2019s a diagram of the macvlan network topology:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/8b111b7c260b8088b55d96bea9e77157/nginx-macvlan.svg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Each container gets its own MAC address and IP address, and each containerized application thinks it\\u2019s on its own host computer. We know the container IP addresses won\\u2019t collide with the DHCP-assigned network addresses because we\\u2019ve allocated different ranges for them. Below, I will detail each step for this setup.\"), mdx(\"h3\", null, \"Choose Docker IP addresses\"), mdx(\"p\", null, \"First, decide on a subset of IP addresses to reserve for Docker. My DHCP server allocates 192.168.0.100-192.169.0.199, so I reserved 192.168.0.200-192.168.0.207 (192.168.0.200/29 in CIDR notation) for Docker containers. Each container will specify its own port in this range, so I can route to each through the nginx reverse proxy.\"), mdx(\"h3\", null, \"Create the macvlan network in Docker\"), mdx(\"p\", null, \"I manage all the Docker containers with Docker compose, but they need to share a single macvlan network so they can communicate with each other. There is no easy way to create a shared network in Docker Compose, so I create one with the Docker CLI:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"bash\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-bash line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"sudo\"), \" docker network create -d macvlan \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"\\\\\"), \"\\n  --subnet\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"192.168\"), \".0.0/24 \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"\\\\\"), \"\\n  --gateway\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"192.168\"), \".0.1 \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"\\\\\"), \"\\n  --ip-range\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"192.168\"), \".0.200/29 \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"\\\\\"), \"\\n  --aux-address \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"'host=192.168.0.101'\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"\\\\\"), \"\\n  -o \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token assign-left variable\"\n  }, \"parent\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \"eth0 vlan\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"p\", null, \"This command creates a macvlan network called \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"vlan\"), \" and allows it to allocate IP addresses 192.168.0.200-192.168.0.207. The parent interface is \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"eth0\"), \", the Ethernet interface of the NAS.\"), mdx(\"h3\", null, \"Reserve Docker IPs and route to them\"), mdx(\"p\", null, \"The containers on the macvlan network are isolated from the host by default. Add a routing rule to route the Docker subset to the macvlan network so the host can see the containers:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"bash\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-bash line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"sudo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"ip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"link\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"add\"), \" macvlan \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"link\"), \" eth0 \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin class-name\"\n  }, \"type\"), \" macvlan mode bridge\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"sudo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"ip\"), \" addr \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"add\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"192.168\"), \".0.101/24 dev macvlan\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"sudo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"ip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"link\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin class-name\"\n  }, \"set\"), \" macvlan up\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"sudo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"ip\"), \" route \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"add\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"192.168\"), \".0.200/29 dev macvlan\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"p\", null, \"These commands add a link network called \\u201Cmacvlan\\u201D to the NAS network configuration. This part was really hard to get right, because it\\u2019s right at the edge of my understanding of Linux networking. The second line attaches the new link to a range of IP addresses starting at 192.168.0.101, the third line starts it up, and the fourth line routes packets addresses to IP addresses 192.168.0.200-192.168.0.207 to the new link, which means they will end up available to the Docker containers.\"), mdx(\"h3\", null, \"Attach the containers to the network in docker-compose files\"), mdx(\"p\", null, \"Finally, now that we have the \\u201Cvlan\\u201D network, we need to specify that each container should attach to it. Add this \\u201Cnetworks\\u201D config to \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"docker-compose.yml\"), \":\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"yml\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-yml line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yml\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token key atrule\"\n  }, \"networks\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token key atrule\"\n  }, \"default\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token key atrule\"\n  }, \"external\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\"), \"\\n      \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token key atrule\"\n  }, \"name\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\"), \" vlan\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"h2\", null, \"GitHub repo\"), mdx(\"p\", null, \"Check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ottobonn/dsm-containers\"\n  }, \"the project on GitHub\"), \" for the full configuration.\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":7}}},"pageContext":{"id":"306b4d38-a53f-5a76-bd9d-58b7ad8d9dbb","slug":"2020/07/05/homeassistant-in-docker-on-synology-nas","__params":{"slug":"2020"}}},
    "staticQueryHashes": []}