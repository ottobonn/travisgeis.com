{
    "componentChunkName": "component---src-pages-project-slug-tsx",
    "path": "/projects/hexo-image-sizes/",
    "result": {"data":{"project":{"id":"hexo-image-sizes","name":"hexo-image-sizes","fields":{"posts":[{"id":"740f5480-d5c4-5f1f-bad2-29a9399e54bf","slug":"2017/03/03/optimizing-image-sizes-in-hexo","title":"Optimizing image sizes in Hexo","lede":"An overview of my image-optimizing plugin for the static site generator.","date":"3 March 2017","rawDate":"2017-03-03T00:00:00.000Z","path":"/2017/03/03/optimizing-image-sizes-in-hexo/","parent":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Optimizing image sizes in Hexo\",\n  \"date\": \"2017-03-03T14:24:26.000Z\",\n  \"tags\": [\"node\", \"hexo\", \"image-processing\"],\n  \"lede\": \"An overview of my image-optimizing plugin for the static site generator.\",\n  \"project\": \"hexo-image-sizes\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I use Hexo to generate my site. It\\u2019s a static site generator, and it follows the typical paradigm of keeping posts (in Markdown format) in a \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"source\"), \" folder, along with images and other resources. The idea is to keep all the \\u201Coriginals\\u201D in the source directory, and then use the site generator to render them to their final display format, into an output directory.\"), mdx(\"p\", null, \"The problem is that source images are large. I want to keep them in their original full resolutions, because I might want to target bigger displays or allow people to download them, and in general because I want the source directory to be a complete archive of the site\\u2019s content.\"), mdx(\"p\", null, \"Instead of serving these huge images to the user, it would be better to make them as small as possible without degrading the experience of looking at them. How big they need to be depends on what they\\u2019re for. If they\\u2019re thumbnails in a gallery, for example, they should be really small files! A full-width banner image should obviously be larger. But none of these likely needs to be the original size, which is often on the order of 4 MB.\"), mdx(\"p\", null, \"Dynamic CMSs like Wordpress already solve this problem, by serving images derived from the ones you upload, resized based on your theme\\u2019s settings. For a static site, putting out images with different viewing \\u201Cprofiles\\u201D should be just as easy, but I didn\\u2019t see a way to do that with Hexo, so I wrote a plugin.\"), mdx(\"h2\", null, \"hexo-image-sizes\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ottobonn/hexo-image-sizes\"\n  }, mdx(\"code\", {\n    parentName: \"a\",\n    \"className\": \"language-text\"\n  }, \"hexo-image-sizes\"), \" plugin\"), \"\\nlets you define image profiles, which specify the optimal size for the image, and then it takes care of generating the images for you. Each source image is then available for use in the original format and in the format of each of the profiles.\"), mdx(\"p\", null, \"You can read about how to use it \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ottobonn/hexo-image-sizes\"\n  }, \"on Github\"), \". I\\u2019m not going to cover that here; instead, I\\u2019d like to discuss some of the design decisions involved in making it.\"), mdx(\"h2\", null, \"How it works\"), mdx(\"h3\", null, \"The Hexo API\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo-image-sizes\"), \" is a Hexo plugin, which means it uses the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hexo.io/api/\"\n  }, \"Hexo API\"), \" to interact with your site\\u2019s files. Hexo has a pretty flexible API, though the documentation is a little too terse for comfort sometimes.\"), mdx(\"p\", null, \"The plugin API revolves around these core concepts:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Plugins are \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"npm\"), \" modules whose names start with \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"hexo-\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hexo loads plugins automatically at start and provides them with the \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"hexo\"), \" global instance object, which includes your site information\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Text files and (and anything else that registers) are \\u201Crendered\\u201D through renderer functions which receive the file data and return its rendered form\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Other files, like images, get copied directly to the output directory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Plugins can register \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"processor\"), \" functions to listen for filenames matching a certain pattern and do things with the filenames\")), mdx(\"h3\", null, \"Renderer?\"), mdx(\"p\", null, \"My first attempt was to make a renderer for the images, to intercept them in the pipeline and resize them. There are two problems here.\"), mdx(\"p\", null, \"The first problem is that renderers are designed to transform the input file into some other, final format, and they can\\u2019t control the name of the output, or how many outputs there should be. So if we want to create multiple different sizes of one source image, a renderer isn\\u2019t the way to go.\"), mdx(\"p\", null, \"The other problem is that we don\\u2019t really want to read the image data into Javascript-land. The image files can be huge, and Hexo loads asynchronously and seemingly without any throttling all the files for which renderers have registered, so the memory penalty of loading all images in order to render them is not acceptable.\"), mdx(\"h3\", null, \"Processor!\"), mdx(\"p\", null, \"Instead, we want to keep the image handling as low-level as possible. The awesome \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lovell/sharp\"\n  }, mdx(\"code\", {\n    parentName: \"a\",\n    \"className\": \"language-text\"\n  }, \"sharp\")), \" module uses a native-compiled \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.vips.ecs.soton.ac.uk/index.php?title=VIPS\"\n  }, mdx(\"code\", {\n    parentName: \"a\",\n    \"className\": \"language-text\"\n  }, \"libvips\")), \" under the hood to handle images, so the memory overhead should be much lower if we can just pass \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"sharp\"), \" the name of an input file and the path to which to write the resized image.\"), mdx(\"p\", null, \"The \\u201Cprocessor\\u201D abstraction in Hexo gives us visibility into the stream of files Hexo is processing for the site. Each processor is simply a function, and it is invoked with a Hexo \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"File\"), \" object as its only argument. The important keys in this object are the \\u201Ctype\\u201D and \\u201Csource\\u201D.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The file \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"type\"), \" indicates what Hexo is doing with it. It\\u2019s one of these strings: \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"create\\\"\"), \", \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"update\\\"\"), \", \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"skip\\\"\"), \", \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"delete\\\"\"), \" (as seen in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/hexojs/hexo/blob/5234c4a85dc6cd418e9a1c169e43de169cf98e95/lib/box/file.js#L33-L36\"\n  }, \"the source code\"), \"; this is an example of where the docs are lacking). For now, I only look at files that we\\u2019re creating or updating, but in the future I should probably handle deleting files as well.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"source\"), \" contains the file\\u2019s full path on disk.\")), mdx(\"p\", null, \"Now we simply need to tell \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"sharp\"), \" this file\\u2019s \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"source\"), \" and where to\\nwrite the output.\"), mdx(\"h3\", null, \"Wither output?\"), mdx(\"p\", null, \"So here\\u2019s the ugly hack of using a processor for generating these images: we receive information about the input file, but we have to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"guess\"), \" the name of the output file. From what I can tell, Hexo simply uses the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"public_dir\"), \" configured in \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"_config.yml\"), \" as the base path, and then tacks on the path of the input file relative to the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"source\"), \" directory. However, that could change, and my plugin wouldn\\u2019t work anymore.\"), mdx(\"p\", null, \"I name the output files based on the original filename and the name of the current profile. So if we have a profile called \\u201Cthumbnail\\u201D, then an image called \\u201Ccat.jpg\\u201D will end up in the output directory at full size as \\u201Ccat.jpg\\u201D and as a thumbnail at \\u201Cthumbnail-cat.jpg\\u201D.\"), mdx(\"p\", null, \"There\\u2019s one more complication, which is that the plugin will run when Hexo starts up. Unfortunately, that means we\\u2019re running ahead of the renderers, and it could be that none of the output directory structure exists yet. After deciding on the full output path, we have to make sure that path exists. I\\u2019m using \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"mkdirp\"), \" to create a directory with all of its intermediate ancestors if it doesn\\u2019t already exist.\"), mdx(\"h3\", null, \"Using the images\"), mdx(\"p\", null, \"So we\\u2019ve resized the images, and now the output directory contains a copy of the original and potentially several resized copies with various names. We could just use one of these new filenames in our Markdown posts directly, but that situation is brittle, because changing the names of profiles could cause images not to show up at all.\"), mdx(\"p\", null, \"While we\\u2019re messing with the images, it\\u2019s a good time to note that Markdown doesn\\u2019t have a mechanism for captioning images, besides repeating some HTML snippet for each one. This too is brittle, and mixes elements of the site\\u2019s theme into the source posts, which is not what we want.\"), mdx(\"p\", null, \"Unfortunately (or maybe fortunately, depending on your bent), Markdown doesn\\u2019t have an official means of extension, so I can\\u2019t build support for captions and image profiles directly. Hexo allows Nunjucks tags in posts through its \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hexo.io/api/tag.html\"\n  }, \"Tag API\"), \", which is the next best option. The upside is that we get a lot more options for controlling the output now, but the tradeoff is that we\\u2019re no longer writing standard Markdown, and our posts depend on this plugin now. I considered this trade for a few days, and decided this was the best course, but it was a tough call.\"), mdx(\"h3\", null, \"The \", mdx(\"code\", {\n    parentName: \"h3\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag\"), mdx(\"p\", null, \"I wanted a tag that is as self-documenting as possible, so if this plugin dies or the posts need to migrate to a different platform, it will be as easy as possible to support these image tags.\"), mdx(\"p\", null, \"There are two choices for passing data to Nunjucks tags: \\u201Cargs\\u201D and \\u201Ccontent.\\u201D A tag looks like this:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-text line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"{% blockquote David Levithan, Wide Awake %}\\nDo not just seek happiness for yourself. Seek happiness for all.\\nThrough kindness. Through mercy.\\n{% endblockquote %}\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  }), mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"args\"), \" is an array formed from the string passed in the tag line. Here, it is \", \"[\\u201CDavid\\u201D, \\u201CLevithan,\\u201D, \\u201CWide\\u201D, \\u201CAwake\\u201D]\", \". Hexo parses the arg line \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/hexojs/hexo/blob/5234c4a85dc6cd418e9a1c169e43de169cf98e95/lib/extend/tag.js#L86-L113\"\n  }, \"here\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"content\"), \" is the string between the opening and closing tags.\")), mdx(\"p\", null, \"Given that I want self-documenting tags, I\\u2019m not too worried about brevity.\\nCopy-and-paste is pretty easy, and authors can set up editor shortcuts to insert these tags if needed.\"), mdx(\"p\", null, \"Passing arguments through the arg line becomes unreadable for more than even a few arguments. The spec for that blockquote tag is:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-text line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"{% blockquote [author[, source]] [link] [source_link_title] %}\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"p\", null, \"These are all positional arguments, and any of them can be elided! Handing that is not easy, and it doesn\\u2019t scale nor is it self-explanatory later.\"), mdx(\"p\", null, \"Instead, I decided to embed a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://yaml.org/start.html\"\n  }, \"YAML\"), \" document in the tag\\u2019s content. YAML is very easy to read, and I don\\u2019t have to write a parser for it. By using a YAML document in the tag content, I can add more arguments in the future without breaking existing documents.\"), mdx(\"p\", null, \"Tags look like this:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-text line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"![Dell Precision 5510 repair](../uploads/2017/01/05/5510-repair.jpg)\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"p\", null, \"We can specify the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"src\"), \" and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"profile\"), \", and alt text. In the future, we could add a caption, and potentially even an output format (.webp, for example). I\\u2019d like to add those possibilities soon.\"), mdx(\"p\", null, \"Since this is normal YAML, other people can write parsers for this tag for their blogging platforms if needed. It\\u2019s a little wordy, but I think it\\u2019s very clear.\"), mdx(\"p\", null, \"There\\u2019s more to come on this project, hopefully soon! I\\u2019m already using this plugin to generate the images on this site. Head over to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ottobonn/hexo-image-sizes\"\n  }, \"Github repo\"), \" to try it out!\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":6}},{"id":"ffaefb95-eaf6-5abe-92e7-634607f8e6a5","slug":"2018/04/23/lazy-image-resizing-in-hexo-image-sizes-v2","title":"Lazy image resizing in hexo-image-sizes v2","lede":"Version 2 of the plugin only resizes the images that actually appear in the blog.","date":"23 April 2018","rawDate":"2018-04-23T00:00:00.000Z","path":"/2018/04/23/lazy-image-resizing-in-hexo-image-sizes-v2/","parent":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Lazy image resizing in hexo-image-sizes v2\",\n  \"tags\": [\"javascript\", \"hexo\"],\n  \"project\": \"hexo-image-sizes\",\n  \"date\": \"2018-04-23T19:18:43.000Z\",\n  \"lede\": \"Version 2 of the plugin only resizes the images that actually appear in the blog.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I just released \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ottobonn/hexo-image-sizes\"\n  }, \"version 2 of\\n\", mdx(\"code\", {\n    parentName: \"a\",\n    \"className\": \"language-text\"\n  }, \"hexo-image-sizes\")), \", which\\nrepresents a complete rewrite of the plugin. It finally supports lazy image\\nresizing. In this post, I will cover the high-level design ideas behind the new\\nversion and some of the challenges in making it.\"), mdx(\"p\", null, \"Check out my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2017/03/03/optimizing-image-sizes-in-hexo/\"\n  }, \"first post on it\"), \" for\\nmore background on the functionality.\"), mdx(\"h2\", null, \"Lazy image resizing with imsize tags\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo-image-sizes\"), \" uses a special tag format for adding images to posts in Hexo.\\nUsers add an \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag to their post when they want to use an image with the\\nplugin, and in the tag they can specify various details of the image including\\nits size profile, its alt text, its link target, and more.\"), mdx(\"p\", null, \"Here\\u2019s an example use of \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" within a markdown post:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"style\": {\n      \"counterReset\": \"linenumber NaN\"\n    },\n    \"className\": \"language-text line-numbers\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"![Arduino Duemilanove](../uploads/2010/06/ArduinoDuemilanove.jpeg)\"), mdx(\"span\", {\n    parentName: \"pre\",\n    \"aria-hidden\": \"true\",\n    \"className\": \"line-numbers-rows\",\n    \"style\": {\n      \"whiteSpace\": \"normal\",\n      \"width\": \"auto\",\n      \"left\": \"0\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\"\n  })))), mdx(\"p\", null, \"When Hexo renders a post containing an \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag, it invokes the tag\\u2019s\\nregistered function. The tag function has access to the user\\u2019s arguments and\\nsome context information including the current page on which it appears, which\\nwill be important for resolving filenames.\"), mdx(\"p\", null, \"The \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag affords the plugin a special ability. Because users must invoke\\nthe tag when they want to embed a resized image in their post,\\n\", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo-image-sizes\"), \" can monitor exactly which images the user has actually made\\nvisible in his or her posts. The new version of the plugin exploits this fact to\\navoid resizing images that the user never makes visible on the site.\"), mdx(\"p\", null, \"The plugin\\u2019s operation now comprises two distinct phases during static site\\ngeneration:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"First, while Hexo renders each post on the site, the plugin monitors all the\\n\", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tags the user includes in posts. Each time the user includes an\\n\", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag, the plugin records which image the user included and the desired\\nnew size in a cache in memory.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"After Hexo has processed all of the posts in the site, the plugin knows\\nwhich images the user wants to make visible. It generates resized versions of\\neach visible image.\")), mdx(\"h2\", null, \"Using Hexo\\u2019s router to avoid filesystem manipulation\"), mdx(\"p\", null, \"Hexo has a router module responsible for tracking which files are in use on the\\nsite and what their contents should be. The router is a map from the path of\\nthe file (relative to the Hexo site\\u2019s public output directory) to a stream\\nof the contents of the file.\"), mdx(\"p\", null, \"The documentation for the router is missing some important details. First, it\\u2019s\\nvery important to know that each route corresponds to a a file in the public\\ndirectory and not in the source directory. Therefore, if you add a route, you\\nwill add a file to the public site but not alter the source directory. When I\\nfirst began work on this plugin, I assumed that the routes referenced files in\\nthe source directory. I learned about using the router from a similar plugin,\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/hexojs/hexo-filter-responsive-images\"\n  }, \"hexo-filter-responsive-images\"), \".\"), mdx(\"p\", null, \"Using the router to add new resized images to the public output of the site\\ngenerator has several advantages. By getting each file\\u2019s contents from the route\\nstream managed by the router, my plugin can start to cooperate with other\\nasset-management plugins, like image filters and minifiers. Using the router\\nalso allows me to remove the hacky filesystem code I was using before, where\\nI had to guess the output location of each file and create the directory\\nstructure there.\"), mdx(\"p\", null, \"Using the router also has a downside. I\\u2019m using\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lovell/sharp\"\n  }, \"sharp\"), \" to resize the images, and it takes as\\ninput either a file or a Buffer of image data, while the router provides a\\nstream for each file. To run the image through \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"sharp\"), \", I have to read the full\\nfile stream into memory (in a Buffer), which adds a lot to the memory use of the\\nplugin. In its original form, the plugin would invoke sharp with file pointers\\ninstead of file contents, which meant that only \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"sharp\"), \" would need to see the\\nfull contents of the image, outside of the JavaScript VM. For my site, the\\nincreased memory use has not been an issue.\"), mdx(\"h2\", null, \"Keeping Hexo running until all images are resized\"), mdx(\"p\", null, \"I discovered that running Hexo in server mode with \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo server\"), \" can behave\\ndifferently than running it to generate files and quit with \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo generate\"), \". My\\nsite would generate without issue when running the server, but \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hexo generate\"), \"\\nwould only produce a few of the necessary images.\"), mdx(\"p\", null, \"The problem was with my \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"after_generate\"), \" filter function. Hexo uses the return\\nvalue of filters to determine when they are finished running, and my filter\\nwasn\\u2019t returning anything. When Hexo was running in server mode, it would keep\\nrunning indefinitely, long enough to allow my plugin to finish resizing\\neverything. In generate mode, it would exit as my plugin was just starting,\\nbecause my filter function seemed to run synchronously.\"), mdx(\"p\", null, \"To fix the issue, I simply return a Promise from the filter function. The\\nPromise resolves when every image has been resized.\"), mdx(\"h2\", null, \"Normalizing file paths throughout the application\"), mdx(\"p\", null, \"Hexo uses several different types of file path, and mixing them was hindering\\nmy development of the plugin for a while. The following paths are involved in\\nresizing an image:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The path the user put in the \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"imsize\"), \" tag, which could be:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Absolute (with a leading slash), meaning it references the Hexo source\\ndirectory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Relative (no leading slash), meaning it is relative to the current post:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the current post is a blog post and has an asset directory\\n(\", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"post_asset_folder\"), \") is true  in Hexo config, then the path starts in the\\nasset directory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the current post is not a blog post or \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"post_asset_folder\"), \" is false,\\nthen the path starts in the directory of the post file.\")))))), mdx(\"p\", null, \"The plugin also has access to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The absolute path to Hexo\\u2019s source directory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The absolute path to the current post\\u2019s source file\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The absolute path to the current post\\u2019s asset directory, if there is one\")), mdx(\"p\", null, \"The plugin computes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A relative path from Hexo\\u2019s source directory to the image the user wants to\\nresize. For example, a cat picture might have path \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"/posts/2018-cats/cat1.jpg\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A copy of that relative path with the image renamed to have its profile name\\nas a prefix. For example, a thumbnail-sized version of the above cat picture\\nmight have path \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"/posts/2018-cats/thumbnail-cat1.jpg\"))), mdx(\"p\", null, \"Once we know the Hexo-relative path to the input image and the output image,\\nwe have all the information necessary to resize the image.\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":4}}]}}},"pageContext":{"id":"hexo-image-sizes","slug":"/projects/hexo-image-sizes","__params":{"slug":"projects"}}},
    "staticQueryHashes": []}